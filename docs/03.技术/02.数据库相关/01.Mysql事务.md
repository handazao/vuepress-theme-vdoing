---
title: Mysql事务
date: 2020-06-12 01:47:58
tags: 
  - Mysql
categories: 
  - 数据库相关
permalink: /pages/68abe9/
author: 
  name: handazao
  link: https://github.com/handazao
---


## 1. 事务基本要素
- 数据库的事务是指一组sql语句组成的数据库逻辑处理单元，在这组的sql操作中，要么全部执行成功，要么全部执行失败
- 事务具有4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）
   + A (Atomicity) 原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样
   + C (Consistency) 一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏
   + I (Isolation)隔离性：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰
   + D (Durability) 持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚
- 原子性：使用 undo log,从而达到回滚
- 持久性：使用 redo log,从而达到故障后恢复
- 隔离性：使用锁以及MVCC,运用的优化思想有读写分离,读读并行,读写并行
- 一致性：通过回滚以及恢复和在并发环境下的隔离做到一致性。
## 2. 事务隔离级别  

   MySQL 的 InnoDB 引擎才支持事务，其中可重复读是默认的隔离级别。 

### 2.1 读未提交（READ UNCOMMITTED） 

   - 读未提交会读到另一个事务的未提交的数据，产生脏读问题   

### 2.2 读提交 （READ COMMITTED）

   - 读提交解决了脏读的，出现了不可重复读，即在一个事务任意时刻读到的数据可能不一样，可能会受到其它事务对数据修改提交后的影响，一般是对于update的操作。  
     
### 2.3 可重复读 （REPEATABLE READ）

- 可重复是对比不可重复而言的，上面说不可重复读是指同一事物不同时刻读到的数据值可能不一致。而可重复读是指，事务不会读到其他事务对已有数据的修改，及时其他事务已提交，也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是，对于其他事务新插入的数据是可以读到的，这也就引发了幻读问题。  
  
### 2.4 串行化 （SERIALIZABLE）

- 串行化是4种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就相当于单线程，后一个事务的执行必须等待前一个事务结束
  
   

| 隔离级别                  | 脏读   | 不可重复读 | 幻读   |
| ------------------------- | ------ | ---------- | ------ |
| 未提交读(Read uncommited) | 可能   | 可能       | 可能   |
| 已提交读(Read commited)   | 不可能 | 可能       | 可能   |
| 可重复读(Repeatable read) | 不可能 | 不可能     | 可能   |
| 串行化(Serializable)      | 不可能 | 不可能     | 不可能 |


脏读

脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。

不可重复读

不可重复读指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。

幻读

幻读是针对数据插入（INSERT）操作来说的。假设事务A对某些行的内容作了更改，但是还未提交，此时事务B插入了与事务A更改前的记录相同的记录行，并且在事务A提交之前先提交了，而这时，在事务A中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务B刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读。  



待续 日志 锁 MVCC
